# Data Store Design

The CT Data Store (CTDS) is a collection of .NET assemblies containing functions to generate and maintain a data repository that provides you with access to consolidated CT7 timetable data, periodically updated from the source timetable databases. The repository is typically used for reporting and publishing purposes, and client applications should consider it read-only.

![IMG.1.0](images/datastore1.0.png?raw=true)

CTDS is available in a form you can use within you own .NET applications. Alternatively, a stand-alone console application is also provided and can be used to 'drive' the process (either manually or via Windows task scheduler).

# Overview of Data Flow

CTDS is all about moving and transforming data. The phases are: 

1. Extraction of Timetables
2. Staging Integrity Check
3. Delta Extraction
4. Federation and Consolidation
5. Public Staging
6. Transformation & Feeding

The data ﬂow is described below:

## Extraction of Timetables

Speciﬁed source timetable databases are copied (almost in their entirety) into a staging area in an ADMIN database. The ADMIN database and source timetable databases don't need to be on the same server. The copying is accomplished quickly using Sql Bulk Insert and has little impact on the performance and availability of source databases (a key requirement).

> **Note:** There are actually three staging schemas in the ADMIN database; “Primary”, “Secondary” and “Temp” (schemas can be thought of as a way of organising data tables in a database, allowing related tables to be grouped together). Source timetables are always copied to the Temp schema ﬁrst. The signiﬁcance of these three schemas is explained later.

A signiﬁcant addition to the staged tables is a column named “src_timetable_id” which is a unique identiﬁer for the source timetable. This allows CTDS to extract data from multiple timetable databases and still be able to determine the origin of each row. As an example, the following image shows the contents of the CT_DEPT table in the ADMIN staging area - it contains department records from two source timetables:

![IMG.1.1](images/datastore1.1.png?raw=true)

The data in the staging tables is almost identical to that in the source tables except for the addition of the src_timetable_id column which is generated by CTDS and refers to a row in the CONTROL.SOURCE_TIMETABLE table.

> **Note:** The staging tables have no indexes, primary keys or referential integrity constraints; they are designed to accommodate a rapid insert of data from the source databases.

Attendance data is modiﬁed slightly during staging to simplify its structure, in particular, the CT_AT_EXCEPTION, CT_AT_STUDENT_EXCEPTION, CT_AT_STUDENT_REGISTER and CT_AT_STUDENT_MARK tables are not staged, rather their content is combined and stored in a single new table in the staging schema called CT_AT_REGISTER_MARK.

## Staging Integrity Check

When the source timetables have been successfully copied into the staging schema they are checked for integrity. In the Extraction phase, data is pulled from source timetables table-by-table, which means that there's a possibility that a data reference in one of the staging tables is not valid in the primary table. For example, suppose CTDS extracts data from a CT_ROOM table and some of the rooms are in a department with dept_id = 10. A few seconds later CTDS extracts the rows from the CT_DEPT table but in the interim, the relevant department has been deleted. This would leave some rooms in the staging database with invalid departments. These are referred to as “broken references” in the CTDS integrity checking routine. 

An additional check is made to ensure that all “consolidation key” values are non-null. Consolidation refers to the process of matching similar records in multiple databases. For example, if you specify that staﬀ are to be matched across timetables by their email addresses, CTDS will check to ensure that each member of staﬀ has a non-null email address. 

At this point there is obviously a possibility that the staged data fails the integrity check. If this happens the whole process is abandoned with a suitable error message and leaving you with the option of retrying at a later time. Crucially, because the staged data is only in the Temp staging schema, the aborted process has not materially aﬀected the data store; it remains in a consistent state. 

If all goes well during staging, the Temp staging data is promoted to the Primary schema (after the Primary schema has ﬁrst been archived to the Secondary schema). This shuﬄing of data (depicted below) is performant since it involves simple schema renaming. And it's an important precursor to the next step in the CTDS workﬂow - discovering what's changed.

![IMG.1.2](images/datastore1.2.png?raw=true)

## Delta Extraction

At this point in the data ﬂow, the Primary staging schema contains the most recent timetable extract, and the Secondary schema contains the extract before that. CTDS now performs a “diﬀ” on the two schemas to ﬁnd the delta (i.e. what's changed in the timetables). Any changes detected are recorded in the ADMIN database “History” schema where there is a corresponding table for each of the staged tables. There are some additional columns in the History schema including the three shown below:

![IMG.1.3](images/datastore1.3.png?raw=true)

The “history_status” column is used to record whether the changed data represents an Insert (“I”), an Update (“U”) or a Deletion “D”.

The “history_stamp” records when the row was added to the history. 

The history_control_log_id is a reference to the CONTROL.LOG table which contains an audit trail of the CTDS activity and is available for troubleshooting, etc. Notice the contents of the LOG table below with id = 5 highlighted - the entry that corresponds to the rows in the above history table.

![IMG.1.4](images/datastore1.4.png?raw=true)

The History schema is never purged; it retains all deltas (changed data) inserted. Maintaining a history of changes like this is a useful source of data in itself. Extracting deltas serves another purpose - it allows CTDS to 'drip-feed' changes into the main user-facing data store rather than updating the store as a whole. This is illustrated below:

![IMG.1.5](images/datastore1.5.png?raw=true)

Feeding data into the public store in this way ensures that it is not subject to large-scale changes and the poor availability that would result. Rather changes are incremental and occur as and when changes are identiﬁed in the source timetables.

## Federation and Consolidation

The History tables contain other important columns as illustrated by the following view of the Department table from the History schema. The highlighted columns contain “federated” and “consolidated” id values for the various key columns in the department table.

![IMG.1.6](images/datastore1.6.png?raw=true)

A **Federated Id** is a bigint value that is generated by CTDS and uniquely identiﬁes a resource in the data store. For example, suppose Department A in Timetable database X has a dept_id value of 100 in that particular database, and Department B in Timetable database Y _also_ has an id of 100. When CTDS extracts data from both timetables and combines them into a single data store it generates a unique identiﬁer for each department record (e.g. 90123 for Department A and 90124 for Department B). This is the department's “federated id” and is used in the History schema with references to a primary table in the “Federation” schema (called FEDERATION.DEPT for departments) which contains details of the source timetable for each resource. 

**Key point** - Every timetable entity (staﬀ, dept, event, etc) is given a new identity when it is pulled into the data store. This identity is called the “Federated Id” and serves to uniquely identify it among other entities of the same type that may have similar native id values. The FEDERATION schema provides a map between native and federated Id values. 

After the delta has been recorded in the History schema (see previous step), CTDS populates these additional “federated” and “consolidated” id columns. This is performed in a strict order as follows: 

1. Any History items that have Deleted status (history_status = 'D') are updated ﬁrst using federation id values that already exist in the Federation schema (since the items must have been previously inserted)

2. New federation Ids are generated for all other History items (Inserts and Updates) as required, and values are applied to the History tables. 

3. The Federation tables are purged of data that corresponds to deleted rows. Note that Federation Id values are not reused. 

4. As History rows are updated with Federation Id values, CTDS sets a “history_federated” ﬂag for each row to indicate that federation of the row is complete. 

Consolidation is a similar process to Federation and occurs at the same time. Consolidation occurs for a subset of entity types (which includes the main resource types) and allows multiple entities from diﬀerent timetables (or even from the same timetable) to be linked together and treated as the same physical resource. This linking of entities is performed automatically by CTDS based upon consolidation parameters speciﬁed in an xml ﬁle or programmatically. It is basically a matter of specifying which column should be used when attempting to match items of a particular type, e.g. use email address when matching staﬀ records, the unique_name ﬁeld to match departments, etc. 

Again an identiﬁer is generated (called the “Consolidated Id”), but this time it may refer to more than a single resource. This information is stored in the Federation schema and it is possible to map between consolidated ids, federated ids and the ids of entities in the original timetables.

## Public Staging

Up to this point, all database updates have occurred in the ADMIN database which is generally only available to system admins or to those with advanced reporting requirements. Once the History schema has been brought up to date, CTDS generates a new staging schema in the PUBLIC database. 

The ﬁrst step in this phase is to ensure that there are no outstanding transformations needed in the public staging schema. If there are then the phase aborts with a suitable error message. 

The Public staging area contains the _changes_ in timetable data (the delta). Once the staging is complete, CTDS marks the corresponding rows in the History schema as “applied” by setting the ﬂag named “history_applied”. This denotes that a particular row in the History schema has been transferred to the public store (or at least to the public staging area) and essentially removes that history row from subsequent processing.

## Transformation & Feeding

The Transformation phase moves data from the Public staging area into the public store. The public store comprises several schemas such as Resource, Attendance, Event, etc. - logical groupings of associated tables. 

During Transformation event data is expanded by week. This means that where a single original event spans ten weeks, for example, CTDS generates ten separate 'event instances' in the public store. The original format (with YN week string) is also retained which means that you can query the public database either by standard CELCAT event or by event instance. 

Finally the public staging area is truncated.

## Mutex

A database mutex is created during the CTDS processing. This is achieved via settings in the Control schema CONFIG table and is designed to prevent multiple CTDS processes operating on the data at the same time.
